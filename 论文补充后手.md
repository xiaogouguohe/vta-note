## 4.3 流水线

从 PyVTA 的硬件架构图，也就是图 4-2 中，可以看出，这样的硬件架构是有实现流水线的潜质的。而 VTA 和 PyVTA 都确实实现了三级的 加载-计算-存储 任务级流水线。在说明如何设计这个流水线之前，首先假设一下，在没有引入流水线的情况下，PyVTA 是如何实现功能的。

### 4.3.1 没有流水线的情况

从图 4-2 可以看出，一个最小的任务，是根据输入和权重，计算出输出，这也是绝大多数神经网络的工作负载。因此，这个任务执行的流程是，加载模块从 DRAM 取出输入和权重，并且加载到输入和权重缓冲区，然后计算模块从输入和权重缓冲区取出输入和权重，存到寄存器文件，并且从微指令缓存取出计算指令，根据计算指令的种类，进行 GEMM 计算或 ALU 计算，最后计算出的结果，写到输出缓冲区，由存储模块取出来，写回 DRAM。

这就是一个最小的任务的执行过程，先后经过了加载模块，计算模块和存储模块。如果没有流水线，那么整个 PyVTA 对这些任务的执行就是，执行完这个计算任务，把输出写回 DRAM 之后，再去执行下一个任务。用图来表示可以是这样的，如图？？？



这样执行任务，显然没有最大程度地利用硬件资源，因为从图？？？中可以看出，在加载模块工作的时候，计算模块和存储模块都处于被阻塞的状态，计算模块要等到加载模块完成这次属于它的任务，并且把输入和权重写到输入和权重缓冲区，计算模块才能开始工作；同理，存储模块要等到计算模块把输出写到输出缓冲区，才能开始工作。这会使得深度学习加速器堆栈的性能大打折扣，为此我们引入流水线来最大限度地降低这种资源浪费。







