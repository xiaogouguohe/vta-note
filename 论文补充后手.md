## 4.3 流水线

从 PyVTA 的硬件架构图，也就是图 4-2 中，可以看出，这样的硬件架构是有实现流水线的潜质的。而 VTA 和 PyVTA 都确实实现了三级的 加载-计算-存储 任务级流水线。在说明如何设计这个流水线之前，首先假设一下，在没有引入流水线的情况下，PyVTA 是如何实现功能的。

### 4.3.1 没有流水线的情况

从图 4-2 可以看出，一个最小的任务，是根据输入和权重，计算出输出，这也是绝大多数神经网络的工作负载。因此，这个任务执行的流程是，加载模块从 DRAM 取出输入和权重，并且加载到输入和权重缓冲区，然后计算模块从输入和权重缓冲区取出输入和权重，存到寄存器文件，并且从微指令缓存取出计算指令，根据计算指令的种类，进行 GEMM 计算或 ALU 计算，最后计算出的结果，写到输出缓冲区，由存储模块取出来，写回 DRAM。

这就是一个最小的任务的执行过程，先后经过了加载模块，计算模块和存储模块。如果没有流水线，那么整个 PyVTA 对这些任务的执行就是，执行完这个计算任务，把输出写回 DRAM 之后，再去执行下一个任务。用图来表示可以是这样的，如图？？？



这样执行任务，显然没有最大程度地利用硬件资源，因为从图？？？中可以看出，在加载模块工作的时候，计算模块和存储模块都处于被阻塞的状态，计算模块要等到加载模块完成这次属于它的任务，并且把输入和权重写到输入和权重缓冲区，计算模块才能开始工作；同理，存储模块要等到计算模块把输出写到输出缓冲区，才能开始工作。这会使得深度学习加速器堆栈的性能大打折扣，为此我们引入流水线来最大限度地降低这种资源浪费，用图？？？来表示这个流水线的设计思路。



从图？？？中可以看出，和非流水线执行这些任务不同， 在加载模块执行任务 t，即从DRAM取输入和权重加载到输入和权重缓冲区时，计算模块可能在执行上一个任务t - 1 的一部分，等到输入和权重被加载到缓冲区时，计算模块可能也执行完了上一个任务 t - 1 中属于它的那部分工作，把结果写入输出缓冲区，于是这时的计算模块从缓冲区取出输入和权重，进行任务 t 计算；同理，计算模块执行任务 t 的时候，存储模块也不会空等，而是可能在执行任务 t - 1 的取出结果并写回DRAM这一步骤。

那么，如何衡量这个流水线对性能的提升呢？基于现有的功能，我们很难去真正观察到执行一个任务时每个模块的耗时，不过基于流水线的理论知识，我们可以大致估计流水线对性能的提高。流水线的目的就是提高吞吐量，在这里，吞吐量可以被量化单位之间内，执行任务的个数。在最理想的情况下，我们假设每个模块执行任务的延时都是相等的，那么在任务源源不断地被执行的理想情况下，这个流水线的性能就是非流水线的三倍，因为非流水线的情况下，需要三个时间周期才能执行一个任务，而引入流水线后，三个时间周期可以执行三个任务。

当然，这是非常理想化的情况，这里至少做了两个理想化的假设，一个是流水线上会有源源不断的任务送进来被执行，另一个是所有模块执行一个任务的属于它的那部分的耗时相等。







